# WB Tech: level # 1 (Golang)

## Устные вопросы
~~~
1) Какой самый эффективный способ конкатенации строк?
- Думал между Strings.Builder и strings.Join, второй оказался быстрее (если верить статье на stackoverflow) 
~~~

~~~
2) Что такое интерфейсы, как они применяются в Go?
- Интерфейс - абстрактный тип, который описывает поведение, но не реализует его. Описывают абстракцию (обобщают) поведение других типов. С помощью такого обобщения позволяют писать более гибкие и адаптируемые функции.
~~~

~~~
3) Чем отличается RWMutex от Mutex?
- RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. (стандартный тип map) 
Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, пока вы не отпустите мьютекс через .Unlock().
Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются, вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя.
Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.
~~~

~~~
4) Чем отличаются буферизированные и не буферизированные каналы?
- Буферизированные каналы обладают емкостью. Пока канал не будет заполнен, он не будет блокировать поток в ожидании прочтения.
~~~

~~~
5) Какой размер у структуры struct{}{}?
- 0 байт
~~~

~~~
6) Есть ли в Go перегрузка методов или операторов?
- Нет
~~~

~~~
7) В какой последовательности будут выведены элементы map[int]int?
Пример: 
m[0] = 1
m[1] = 124
m[2] = 281

- С 0 элемента до последнего
~~~

~~~
8) В чем разница между make и new?
- Make возвращает объект, New возвращает указатель на объект
~~~

~~~
9) Сколько существует способов задать переменную типа slice или map?
- 3 способа:
slice:
- var testSlice[]int
- testSlice := []int{}
- testSlice := new([]int)
map:
- var testMap map[int]int
- testMap := map[int]int{}
- testMap := make(map[int]int) 
~~~

~~~
10) Что выведет данная программа и почему?

func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)

	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}

- Выведет в обоих случаях 1, потому что функция update работает не с переменной, а с ее указателем. И получается мы меняем указатель, а не переменную. Чтобы распечаталось 1 и 2, нужно строчку p = &b заменить на *p = b.
~~~

~~~
11) Что выведет данная программа и почему?

func main() {
	wg := sync.WaitGroup{}
	
	for i := 0; i < 5; i++ {
		wg.Add(1)

		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

- Будет паника, дедлок. В функцию передается копия начального WaitGroup и она же изменяется при Done(), в то время как за пределами горутины добавляется задание и ожидает завершения.
Учитывая, что анон. функция находится внутри, где уже есть WaitGroup, то мы можем не передавать ее в функцию, а работать напрямую.
~~~

~~~
12) Что выведет данная программа и почему?

func main() {
	n := 0

	if true {
		n := 1
		n++
	}

	fmt.Println(n)
}

- Выведет 0. В условии мы создаем новую переменную n, а за пределами выводится старая переменная равная нулю. Чтобы сработало условие, нужно n := 1 заменить на n = 1
~~~

~~~
13) Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}

- Выведет [100 2 3 4 5]. Первый элемент изменился, потому что функция someAction работает с копией. Но меняя значение среза, мы меняем значения и в массиве, на основе которого сделан срез.
~~~

~~~
14) Что выведет данная программа и почему? 

func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Println(slice)
	}(slice)
	fmt.Println(slice)
}

- Первая часть выведет [b b a] потому, что к копии добавляют еще один элемент, затем первые два меняют и вывод записан в поле видимости функции.
После выхода из этой функции выводится старый срез [a a].
~~~